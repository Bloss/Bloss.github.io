(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{95:function(e,v,t){"use strict";t.r(v);var a=t(3),_=Object(a.a)({},function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"自顶向下"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自顶向下","aria-hidden":"true"}},[e._v("#")]),e._v(" 自顶向下")]),e._v(" "),t("p",[e._v("这边用统一的一个原生壳去管理, 调用所有的模块("),t("code",[e._v("native")]),e._v(", "),t("code",[e._v("RN")]),e._v(" 和 "),t("code",[e._v("H5")]),e._v("), 模块之间通过自定义的协议互相跳转, 调用. 这样的好处是, 模块之间互相不依赖, 相互独立, 更稳定, 便于管理. 所以, 这个协议调用自然是重中之重\n")]),e._v(" "),t("h3",{attrs:{id:"native"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#native","aria-hidden":"true"}},[e._v("#")]),e._v(" native")]),e._v(" "),t("h3",{attrs:{id:"javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript","aria-hidden":"true"}},[e._v("#")]),e._v(" javaScript")]),e._v(" "),t("p",[e._v("这边主要说的是模块("),t("code",[e._v("RN")]),e._v(", "),t("code",[e._v("H5")]),e._v(", "),t("code",[e._v("native")]),e._v(")之间的调用")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("RN: "),t("code",[e._v("RN")]),e._v(" 之间调用自然不成问题, 在壳里用一个全局的 "),t("code",[e._v("helper")]),e._v(" 来管理 "),t("code",[e._v("RN router")]),e._v(" 即可")])]),e._v(" "),t("li",[t("p",[e._v("H5 和 native: 这俩个明明不是一个东西, 我们为什么放到一起说呢? 因为他们本质都是通过 "),t("code",[e._v("native")]),e._v(" 来调用的("),t("code",[e._v("H5")]),e._v(" 既是 "),t("code",[e._v("webview")]),e._v("). 我们只需要根据协议 "),t("code",[e._v("schema")]),e._v(" 的不同在 "),t("code",[e._v("native")]),e._v(" 中做出对应操作即可")])])])])},[],!1,null,null,null);_.options.__file="framework.md";v.default=_.exports}}]);